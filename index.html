<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>LeKimLam - HUMAN TRACKER ONLY</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<!-- Font Qu√¢n s·ª± -->
<link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap" rel="stylesheet">

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

<style>
    :root {
        --color-safe: #00ffcc;
        --color-lock: #ff3300;
        --bg-glass: rgba(0, 20, 10, 0.7);
    }

    body { 
        margin: 0; background: #000; overflow: hidden; 
        font-family: 'Chakra Petch', sans-serif; 
    }

    /* K√≠nh ng·∫Øm Crosshair ·ªü gi·ªØa m√†n h√¨nh */
    #crosshair {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        width: 40px; height: 40px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        z-index: 15; pointer-events: none;
    }
    #crosshair::before, #crosshair::after {
        content: ''; position: absolute; background: rgba(255, 255, 255, 0.5);
    }
    #crosshair::before { top: 19px; left: 0; width: 40px; height: 2px; }
    #crosshair::after { top: 0; left: 19px; width: 2px; height: 40px; }

    #viewport { position: relative; width: 100vw; height: 100vh; }
    
    video { 
        position: absolute; width: 100%; height: 100%; 
        object-fit: cover; filter: brightness(0.9) contrast(1.1);
    }
    
    canvas { position: absolute; width: 100%; height: 100%; object-fit: cover; z-index: 10; }

    /* UI Info */
    #hud-top {
        position: fixed; top: 20px; left: 20px;
        color: var(--color-safe); font-size: 14px;
        text-shadow: 0 0 5px var(--color-safe);
        z-index: 20;
    }
    .status-active { color: var(--color-lock) !important; text-shadow: 0 0 10px red !important; }

    #loader {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: #000; z-index: 100;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        color: var(--color-safe);
    }
</style>
</head>
<body>

<div id="loader">
    <h2>SYSTEM BOOT...</h2>
    <p>LOADING HUMAN RECOGNITION MODULE</p>
</div>

<div id="crosshair"></div>

<div id="viewport">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
</div>

<div id="hud-top">
    <div>MODE: <span id="mode-status">SEARCHING...</span></div>
    <div>HUMANS DETECTED: <span id="count">0</span></div>
</div>

<script>
/**
 * LEKIMLAM - STRICT HUMAN TRACKING
 */

const CONFIG = {
    TARGET_CLASS: 'person', // CH·ªà CH·∫§P NH·∫¨N NG∆Ø·ªúI
    MIN_SCORE: 0.60,        // ƒê·ªô tin c·∫≠y > 60% m·ªõi b·∫Øt (L·ªçc nhi·ªÖu)
    SMOOTH_FACTOR: 0.25,    // ƒê·ªô m∆∞·ª£t khi di chuy·ªÉn
    IOU_THRESHOLD: 0.4
};

let state = {
    model: null,
    tracks: [],
    videoWidth: 0,
    videoHeight: 0
};

const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('mode-status');
const countEl = document.getElementById('count');
const hudEl = document.getElementById('hud-top');

// --- 1. CORE TRACKING LOGIC ---

function getIoU(box1, box2) {
    const [x1, y1, w1, h1] = box1;
    const [x2, y2, w2, h2] = box2;
    const xi1 = Math.max(x1, x2), yi1 = Math.max(y1, y2);
    const xi2 = Math.min(x1 + w1, x2 + w2), yi2 = Math.min(y1 + h1, y2 + h2);
    const inter = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);
    return inter / ((w1*h1) + (w2*h2) - inter);
}

function updateTracks(predictions) {
    // B∆Ø·ªöC 1: L·ªåC TUY·ªÜT ƒê·ªêI (STRICT FILTER)
    const humans = predictions.filter(p => 
        p.class === CONFIG.TARGET_CLASS && 
        p.score > CONFIG.MIN_SCORE
    );

    // Reset tr·∫°ng th√°i "ƒë√£ th·∫•y" c·ªßa c√°c track c≈©
    state.tracks.forEach(t => t.seen = false);

    humans.forEach(human => {
        let bestMatch = null;
        let maxIoU = 0;

        // T√¨m track c≈© kh·ªõp v·ªõi human m·ªõi ph√°t hi·ªán
        state.tracks.forEach(track => {
            const iou = getIoU(track.box, human.bbox);
            if (iou > maxIoU) {
                maxIoU = iou;
                bestMatch = track;
            }
        });

        if (bestMatch && maxIoU > CONFIG.IOU_THRESHOLD) {
            // C·∫≠p nh·∫≠t v·ªã tr√≠ (Smooth)
            bestMatch.target = human.bbox;
            bestMatch.score = human.score;
            bestMatch.seen = true;
            bestMatch.missFrames = 0;
        } else {
            // T·∫°o m·ªõi
            state.tracks.push({
                id: Math.floor(Math.random() * 10000),
                box: [...human.bbox],    // Hi·ªán t·∫°i
                target: [...human.bbox], // ƒê√≠ch ƒë·∫øn
                score: human.score,
                seen: true,
                missFrames: 0,
                lockTime: Date.now()
            });
        }
    });

    // X√≥a track n·∫øu m·∫•t d·∫•u qu√° 10 frame
    state.tracks = state.tracks.filter(t => {
        if (!t.seen) t.missFrames++;
        return t.missFrames < 10;
    });

    // Update UI Status
    countEl.innerText = state.tracks.length;
    if (state.tracks.length > 0) {
        statusEl.innerText = "TARGET LOCKED";
        statusEl.classList.add('status-active');
        hudEl.style.color = "var(--color-lock)";
    } else {
        statusEl.innerText = "SEARCHING...";
        statusEl.classList.remove('status-active');
        hudEl.style.color = "var(--color-safe)";
    }
}

function lerp(start, end, amt) {
    return (1 - amt) * start + amt * end;
}

// --- 2. RENDERER (TACTICAL STYLE) ---

function draw() {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    state.tracks.forEach(t => {
        // Interpolation (L√†m m∆∞·ª£t)
        t.box[0] = lerp(t.box[0], t.target[0], CONFIG.SMOOTH_FACTOR);
        t.box[1] = lerp(t.box[1], t.target[1], CONFIG.SMOOTH_FACTOR);
        t.box[2] = lerp(t.box[2], t.target[2], CONFIG.SMOOTH_FACTOR);
        t.box[3] = lerp(t.box[3], t.target[3], CONFIG.SMOOTH_FACTOR);

        const [x, y, w, h] = t.box;
        
        // M√†u s·∫Øc: ƒê·ªè (Locked)
        const color = '#ff3300'; 
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.fillStyle = color;

        // 1. V·∫Ω Khung Tactical (4 g√≥c)
        const len = 20;
        ctx.beginPath();
        // Top Left
        ctx.moveTo(x, y + len); ctx.lineTo(x, y); ctx.lineTo(x + len, y);
        // Top Right
        ctx.moveTo(x + w - len, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + len);
        // Bottom Right
        ctx.moveTo(x + w, y + h - len); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - len, y + h);
        // Bottom Left
        ctx.moveTo(x + len, y + h); ctx.lineTo(x, y + h); ctx.lineTo(x, y + h - len);
        ctx.stroke();

        // 2. Head-Shot Circle (Gi·∫£ l·∫≠p v·ªã tr√≠ ƒë·∫ßu)
        // Th√¥ng th∆∞·ªùng ƒë·∫ßu ng∆∞·ªùi chi·∫øm kho·∫£ng 1/6 - 1/8 chi·ªÅu cao, n·∫±m ·ªü tr√™n c√πng
        const headRadius = w / 5;
        const headX = x + w / 2;
        const headY = y + (h / 6); // ∆Ø·ªõc l∆∞·ª£ng v·ªã tr√≠ ƒë·∫ßu
        
        ctx.beginPath();
        ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
        ctx.setLineDash([2, 2]); // N√©t ƒë·ª©t
        ctx.stroke();
        ctx.setLineDash([]); // Reset n√©t

        // T√¢m ƒëi·ªÉm ƒë·∫ßu
        ctx.fillRect(headX - 2, headY - 2, 4, 4);

        // 3. Info Text
        ctx.font = '12px "Chakra Petch"';
        ctx.fillText(`HUMAN-ID: ${t.id}`, x, y - 20);
        ctx.fillText(`CONF: ${Math.round(t.score * 100)}%`, x, y - 5);

        // 4. Center Mass Line (ƒê∆∞·ªùng n·ªëi t·ª´ ƒë·∫ßu xu·ªëng t√¢m)
        ctx.beginPath();
        ctx.moveTo(headX, headY + headRadius);
        ctx.lineTo(x + w/2, y + h/2);
        ctx.globalAlpha = 0.5;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    });

    requestAnimationFrame(draw);
}

// --- 3. SETUP ---

async function init() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
            audio: false
        });
        video.srcObject = stream;
        
        // Load model Full (Ch√≠nh x√°c h∆°n Lite) ƒë·ªÉ ph√¢n bi·ªát ng∆∞·ªùi t·ªët h∆°n
        state.model = await cocoSsd.load({ base: 'mobilenet_v2' });
        
        document.getElementById('loader').style.display = 'none';
        video.play();
        
        detectLoop();
        draw();

    } catch (err) {
        alert("L·ªói Camera: " + err.message);
    }
}

async function detectLoop() {
    if (!state.model) return;
    try {
        const preds = await state.model.detect(video);
        updateTracks(preds);
    } catch (e) {}
    requestAnimationFrame(detectLoop);
}

init();

</script>
</body>
</html>        position: absolute; width: 100%; height: 100%; 
        object-fit: cover; filter: contrast(1.2) brightness(0.8); /* T·ªëi ƒëi m·ªôt ch√∫t ƒë·ªÉ nguy hi·ªÉm h∆°n */
    }
    
    canvas { position: absolute; width: 100%; height: 100%; object-fit: cover; }

    /* UI Layer */
    #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }

    .header {
        position: absolute; top: 0; left: 0; width: 100%; padding: 15px;
        background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
        display: flex; justify-content: space-between; align-items: center;
    }

    .status-box {
        border: 2px solid var(--safe); color: var(--safe);
        padding: 5px 15px; font-family: 'Black Ops One'; font-size: 24px;
        background: rgba(0,0,0,0.7); text-transform: uppercase;
    }
    
    .danger-mode .status-box {
        border-color: var(--danger); color: var(--danger);
        text-shadow: 0 0 10px red;
    }

    .log-area {
        position: absolute; bottom: 100px; left: 10px;
        color: var(--danger); font-size: 12px;
        text-shadow: 1px 1px 0 #000;
    }

    .controls {
        position: absolute; bottom: 30px; width: 100%;
        display: flex; justify-content: center; gap: 20px; pointer-events: auto;
    }

    button {
        background: #333; color: white; border: 1px solid #555;
        padding: 15px 30px; font-weight: bold; cursor: pointer;
        text-transform: uppercase; clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
    }
    button.arm-btn { background: var(--danger); border: none; color: black; }
    button:active { transform: scale(0.95); }

    #evidence-flash {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: white; z-index: 100; opacity: 0; pointer-events: none;
        transition: opacity 0.1s;
    }
</style>
</head>
<body id="body">

<div id="evidence-flash"></div>

<div id="viewport">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
</div>

<div id="ui-layer">
    <div class="header">
        <div id="status-display" class="status-box">SYSTEM ARMED</div>
        <div style="color:white; font-size:12px">REC ‚óè</div>
    </div>
    
    <div class="log-area" id="log">Waiting for movement...</div>

    <div class="controls">
        <button class="arm-btn" onclick="toggleArm()" id="btn-arm">DISARM</button>
        <button onclick="toggleSound()" id="btn-sound">SOUND: ON</button>
    </div>
</div>

<script>
/**
 * LEKIMLAM SECURITY - SENTRY CORE
 */

// --- 1. SIREN SYSTEM (C√íI H√ö) ---
// S·ª≠ d·ª•ng Web Audio API ƒë·ªÉ kh√¥ng c·∫ßn file mp3
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let oscillator = null;
let gainNode = null;
let isSirenPlaying = false;
let soundEnabled = true;

function startSiren() {
    if (!soundEnabled || isSirenPlaying) return;
    isSirenPlaying = true;

    oscillator = audioCtx.createOscillator();
    gainNode = audioCtx.createGain();
    
    oscillator.type = 'sawtooth'; // √Çm thanh g·∫Øt
    oscillator.frequency.value = 500;
    
    // Hi·ªáu ·ª©ng l√™n xu·ªëng (Wee-Woo)
    oscillator.frequency.setValueAtTime(500, audioCtx.currentTime);
    oscillator.frequency.linearRampToValueAtTime(1000, audioCtx.currentTime + 0.3);
    oscillator.frequency.linearRampToValueAtTime(500, audioCtx.currentTime + 0.6);
    
    // Loop hi·ªáu ·ª©ng
    setInterval(() => {
        if(oscillator && isSirenPlaying) {
            const now = audioCtx.currentTime;
            oscillator.frequency.setValueAtTime(500, now);
            oscillator.frequency.linearRampToValueAtTime(1000, now + 0.3);
            oscillator.frequency.linearRampToValueAtTime(500, now + 0.6);
        }
    }, 600);

    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    oscillator.start();
}

function stopSiren() {
    if (oscillator) {
        oscillator.stop();
        oscillator.disconnect();
        oscillator = null;
    }
    isSirenPlaying = false;
}

// --- 2. SECURITY CONFIG ---
const CONFIG = {
    CONFIDENCE: 0.55,
    HISTORY_LENGTH: 20, // ƒê·ªô d√†i ƒëu√¥i di chuy·ªÉn
    ALARM_COOLDOWN: 100 // Frame
};

let state = {
    model: null,
    armed: true, // M·∫∑c ƒë·ªãnh b·∫≠t b√°o ƒë·ªông
    alarmActive: false,
    tracks: [], // L∆∞u tr·ªØ v·∫≠t th·ªÉ v√† l·ªãch s·ª≠ di chuy·ªÉn
    lastEvidenceTime: 0
};

const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status-display');
const bodyEl = document.getElementById('body');
const logEl = document.getElementById('log');

// --- 3. TRACKING & TRAIL LOGIC ---

function updateTracks(preds) {
    // Ch·ªâ quan t√¢m ƒë·∫øn NG∆Ø·ªúI (Person)
    const persons = preds.filter(p => p.class === 'person' && p.score > CONFIG.CONFIDENCE);

    if (persons.length === 0) {
        // N·∫øu kh√¥ng th·∫•y ai, reset b√°o ƒë·ªông sau m·ªôt l√∫c
        if (state.alarmActive) {
            stopSiren();
            state.alarmActive = false;
            bodyEl.classList.remove('alert-active');
            statusEl.innerText = "SYSTEM ARMED";
            bodyEl.classList.remove('danger-mode');
        }
        state.tracks = [];
        return;
    }

    // N·∫øu th·∫•y ng∆∞·ªùi v√† ƒëang ARMED -> B√ÅO ƒê·ªòNG NGAY
    if (state.armed && !state.alarmActive) {
        triggerAlarm();
    }

    // C·∫≠p nh·∫≠t v·ªã tr√≠ ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng ƒëi
    // ƒê∆°n gi·∫£n h√≥a: X√≥a track c≈©, t·∫°o track m·ªõi m·ªói frame (cho demo m∆∞·ª£t)
    // Trong th·ª±c t·∫ø c·∫ßn ID matching, nh∆∞ng ·ªü ƒë√¢y ta v·∫Ω ƒë√® l√™n
    
    // Logic v·∫Ω ƒëu√¥i (Trail):
    // Ta c·∫ßn l∆∞u v·ªã tr√≠ c≈©. V√¨ demo ƒë∆°n gi·∫£n, ta s·∫Ω push v·ªã tr√≠ v√†o m·∫£ng to√†n c·ª•c
    // N·∫øu c√≥ nhi·ªÅu ng∆∞·ªùi, logic n√†y s·∫Ω n·ªëi t·∫•t c·∫£ l·∫°i (ch·∫•p nh·∫≠n ƒë∆∞·ª£c cho demo security 1 cam)
    
    const person = persons[0]; // L·∫•y ng∆∞·ªùi r√µ nh·∫•t
    const centerX = person.bbox[0] + person.bbox[2]/2;
    const centerY = person.bbox[1] + person.bbox[3]/2;

    state.tracks.push({x: centerX, y: centerY});
    if (state.tracks.length > CONFIG.HISTORY_LENGTH) state.tracks.shift();

    drawSecurityHUD(person);
}

function triggerAlarm() {
    state.alarmActive = true;
    statusEl.innerText = "‚ö†Ô∏è INTRUDER DETECTED ‚ö†Ô∏è";
    bodyEl.classList.add('danger-mode');
    bodyEl.classList.add('alert-active'); // Hi·ªáu ·ª©ng ƒë·ªè m√†n h√¨nh
    
    logEl.innerText = `[${new Date().toLocaleTimeString()}] THREAT DETECTED!`;
    
    startSiren();
    takeEvidencePhoto();
}

function takeEvidencePhoto() {
    const now = Date.now();
    if (now - state.lastEvidenceTime > 3000) { // Ch·ª•p m·ªói 3 gi√¢y
        state.lastEvidenceTime = now;
        
        // Hi·ªáu ·ª©ng Flash
        const flash = document.getElementById('evidence-flash');
        flash.style.opacity = 1;
        setTimeout(() => flash.style.opacity = 0, 100);

        // L∆∞u ·∫£nh (Code gi·∫£ l·∫≠p, th·ª±c t·∫ø s·∫Ω g·ª≠i v·ªÅ server)
        console.log("üì∏ EVIDENCE CAPTURED");
    }
}

// --- 4. RENDERER ---
function drawSecurityHUD(person) {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const [x, y, w, h] = person.bbox;
    const color = state.alarmActive ? '#ff0000' : '#00ff00';

    // 1. V·∫Ω ƒë∆∞·ªùng di chuy·ªÉn (Motion Trail)
    if (state.tracks.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.moveTo(state.tracks[0].x, state.tracks[0].y);
        for (let i = 1; i < state.tracks.length; i++) {
            ctx.lineTo(state.tracks[i].x, state.tracks[i].y);
        }
        ctx.stroke();
        
        // V·∫Ω c√°c ƒëi·ªÉm ch·ªët
        state.tracks.forEach(p => {
            ctx.fillStyle = color;
            ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
        });
    }

    // 2. V·∫Ω khung ng·∫Øm m·ª•c ti√™u (Target Lock)
    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    ctx.strokeRect(x, y, w, h);

    // 3. ƒê∆∞·ªùng ch√©o kh√≥a m·ª•c ti√™u (Crosshair)
    ctx.beginPath();
    ctx.moveTo(x + w/2, y); ctx.lineTo(x + w/2, y + h); // D·ªçc
    ctx.moveTo(x, y + h/2); ctx.lineTo(x + w, y + h/2); // Ngang
    ctx.globalAlpha = 0.3;
    ctx.stroke();
    ctx.globalAlpha = 1.0;

    // 4. Th√¥ng tin m·ª•c ti√™u
    ctx.fillStyle = color;
    ctx.font = 'bold 16px "Roboto Mono"';
    ctx.fillText("TARGET: HUMAN", x, y - 10);
    ctx.fillText(`CONFIDENCE: ${Math.round(person.score*100)}%`, x, y + h + 20);
}

async function aiLoop() {
    if (!state.model) return;
    try {
        const preds = await state.model.detect(video);
        updateTracks(preds);
    } catch (e) {}
    requestAnimationFrame(aiLoop);
}

// --- 5. SETUP ---
async function main() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment', width: {ideal: 1280}, height: {ideal: 720} },
            audio: false
        });
        video.srcObject = stream;
        
        state.model = await cocoSsd.load({ base: 'mobilenet_v2' });
        
        logEl.innerText = "System Online. Scanning...";
        video.play();
        aiLoop();

    } catch (err) {
        alert("Cam Error: " + err.message);
    }
}

// Controls
function toggleArm() {
    state.armed = !state.armed;
    const btn = document.getElementById('btn-arm');
    
    if (state.armed) {
        statusEl.innerText = "SYSTEM ARMED";
        statusEl.style.borderColor = "var(--safe)"; // M√†u xanh ch·ªù ƒë·ª£i
        statusEl.style.color = "var(--safe)";
        btn.innerText = "DISARM";
        btn.style.background = "var(--danger)";
        logEl.innerText = "System Armed. Movement will trigger alarm.";
    } else {
        statusEl.innerText = "STANDBY";
        statusEl.style.borderColor = "#555";
        statusEl.style.color = "#aaa";
        btn.innerText = "ARM SYSTEM";
        btn.style.background = "#333";
        stopSiren();
        state.alarmActive = false;
        bodyEl.classList.remove('alert-active');
        bodyEl.classList.remove('danger-mode');
        logEl.innerText = "System Disarmed.";
    }
}

function toggleSound() {
    soundEnabled = !soundEnabled;
    document.getElementById('btn-sound').innerText = soundEnabled ? "SOUND: ON" : "SOUND: OFF";
    if (!soundEnabled) stopSiren();
}

// Start interaction required for AudioContext
document.body.addEventListener('click', () => {
    if (audioCtx.state === 'suspended') audioCtx.resume();
}, {once:true});

main();

</script>
</body>
</html>4
